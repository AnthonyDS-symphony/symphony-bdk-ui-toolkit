import {
  Story, Meta, Preview, Props, Link, Anchor, Description
} from '@storybook/addon-docs/blocks';

<Meta title="Bot Developer Kit/Bot SDK"  parameters={{order: 3}}/>

# Bot SDK
---
[![CircleCI](https://circleci.com/gh/SymphonyPlatformSolutions/symphony-bdk-bot-sdk-java.svg?style=shield&circle-token=f7891ef2a6f117938ef4ee885076c2d2bcd9b9cd)](https://circleci.com/gh/SymphonyPlatformSolutions/symphony-bdk-bot-sdk-java)
[![Maven Central](https://img.shields.io/maven-central/v/com.symphony.platformsolutions/symphony-bdk-bot-sdk-java)](https://mvnrepository.com/artifact/com.symphony.platformsolutions/symphony-bdk-bot-sdk-java)

## Description
The Bot SDK extends the Symphony Java SDK in providing an implementation of baseline best
practices. This includes structures for handling commands, message templating, Symphony
Elements, webhook notifications, third-party authentication / REST APIs and many more.

## Summary

* [Getting Started](#getting-started)
  * [Prerequisites](#prerequisites)
  * [Setting the service account](#setting-the-service-account)
  * [POD configuration](#pod-configuration)
  * [Running locally](#running-locally)
  * [Verify your setup](#verify-your-setup)
* [Testing commands](#testing-commands)
  * [Help command](#help-command)
  * [Hello command](#hello-command)
  * [Create notification command](#create-notification-command)
  * [Login command](#login-command)
  * [Quote command](#quote-command)
  * [Template command](#template-command)
  * [Register quote command](#register-quote-command)
  * [Attachment command](#attachment-command)
  * [Default response](#default-response)
* [Testing events](#testing-events)
* [Testing notifications](#testing-notifications)
* [Adding bot commands](#adding-bot-commands)
  * [Command initialization](#command-initialization)
  * [Default responses](#default-responses)
  * [Authenticating to external system](#authenticating-to-external-system)
    * [AuthenticationProvider](#authenticationprovider)
    * [AuthenticatedCommandHandler](#authenticatedcommandhandler)
  * [Command Matcher](#command-matcher)
* [Handling Symphony events](#handling-symphony-events)
  * [Available Symphony events](#available-symphony-events)
  * [Permission for bots in public rooms](#permission-for-bots-in-public-rooms)
* [Working with Symphony Elements](#working-with-symphony-elements)
  * [ElementsActionHandler](#elementsactionhandler)
* [Receiving notifications](#receiving-notifications)
  * [Processing incoming requests](#processing-incoming-requests)
  * [Controlling interceptors order](#controlling-interceptors-order)
  * [Forwarding notifications to rooms](#forwarding-notifications-to-rooms)
  * [Protecting notifications endpoint](#protecting-notifications-endpoint)
* [Sending messages](#sending-messages)
  * [Using Symphony standard templates](#using-symphony-standard-templates)
* [Extending health metrics](#extending-health-metrics)
* [Extension applications](#extension-applications)
  * [Extension app authentication](#extension-app-authentication)
  * [Exposing new endpoints](#exposing-new-endpoints)
  * [Protecting endpoints](#protecting-endpoints)
  * [Symphony clients](#symphony-clients)
  * [Serving the extension app](#serving-the-extension-app)
  * [Testing your app](#testing-your-app)
    * [Streams details endpoint](#streams-details-endpoint)
    * [Users details endpoint](#users-details-endpoint)
    * [Extension app log endpoint](#extension-app-log-endpoint)
    * [Static content](#static-content)
  * [Automatic endpoint documentation](#automatic-endpoint-documentation)
* [Real-Time events](#real-time-events)
  * [Generating events](#generating-events)
  * [Subscribing to event streams](#subscribing-to-event-streams)
  * [Event stream mapping](#event-stream-mapping)
  * [Filtering events](#filtering-events)
* [Advanced settings](#advanced-settings)
  * [Custom truststore](#custom-truststore)
  * [Proxy support](#proxy-support)
  * [Logging](#logging)
  * [Access control](#access-control)
  * [CORS](#cors)
  * [Cross-site scripting](#cross-site-scripting)
  * [Request origin header](#request-origin-header)
  * [Rate limit](#rate-limit)
  * [Settings reference](#settings-reference)

## Getting Started
These instructions will help you set up your project with the Bot SDK.

### Prerequisites
* JDK 8
* Maven 3
* Service account configured in Symphony Admin Portal
* (Optional) Extension app configured in Symphony Admin Portal

### Configuration
In the `src/main/resources/bot-config.json` file, you will find the following
configuration properties to specify the details of your environment. Ensure that all
details accurately reflect your environment configuration. When in doubt, please seek
assistance from your pod administrator.

|            Property            |                Description                |
|--------------------------------|-------------------------------------------|
| sessionAuthHost                | The Session authentication host URL       |
| sessionAuthPort                | The Session authentication host port      |
| keyAuthHost                    | The Key Manager authentication host URL   |
| keyAuthPort                    | The Key Manager authentication host port  |
| podHost                        | The Pod host URL                          |
| podPort                        | The Pod host port                         |
| agentHost                      | The Agent host URL                        |
| agentPort                      | The Agent host port                       |
| botUsername                    | The Bot's username                        |
| botPrivateKeyPath              | The Bot's private key path                |
| botPrivateKeyName              | The Bot's private key file                |
| appId                          | The Extension App's identifier            |
| appPrivateKeyPath              | The Extension App's private key path      |
| appPrivateKeyName              | The Extension App's private key file      |

### Running locally
The Bot SDK is built on top of Spring Boot and uses Maven to manage dependencies. You can
follow the commands below if you are not using an IDE.

##### Step 1: Install dependencies
```bash
mvn clean install
```
##### Step 2: Run application
For a standard run:
```bash
mvn clean spring-boot:run
```
For a debug run:
```bash
mvn clean spring-boot:run -Dspring-boot.run.jvmArguments="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"
```
Bind the debugger of your choice the the specified port (e.g. 5005).


### Verify your setup

Once the application is up and running, you can check if all the setup works properly by
navigating to the health check endpoint:
`http://hostname:port/application_context/monitor/health`.

If you setup your project using the BDK CLI under the name `myapp`, you should go to
`http://localhost:8080/myapp/monitor/health`

This endpoint provides health metrics for your app, including network connectivity and
environment information like versions of the Symphony components it is connected to.

```json
{
    "status":"UP",
    "details":{
        "diskSpace":{
            "status":"UP",
            "details":{
                "total":267985612800,
                "free":110894546944,
                "threshold":10485760
            }

        },
        "symphony":{
            "status":"UP",
            "details":{
                "Symphony":{
                    "agentConnection":"UP",
                    "podConnection":"UP",
                    "agentToPodConnection":"UP",
                    "agentToKMConnection":"UP",
                    "podVersion":"1.55.3",
                    "agentVersion":"2.55.9",
                    "agentToPodConnectionError":"N/A",
                    "agentToKMConnectionError":"N/A"
                }

            }

        },
        "internetConnectivity":{
            "status":"UP",
            "details":{
                "connectivity":"UP"
            }
        }
    }
}
```

## Testing the sample commands
Sample commands ship with the Bot SDK to help developers understand the way the SDK
structure. To test these, launch Symphony and search for the display name of your bot's
service account, then start a chat conversation with it.

All sample commands require being prefixed with an `@mention` of the bot, though you can
choose to specify any other pattern when creating your own commands.

### Help command

Displays static help message with all available commands

>&#9679; **John Doe**
>
>@MyBot /help

>&#9679; **MyBot**
>
>Bot Commands
>- **@MyBot** /hello - simple hello command
>- **@MyBot** /help - displays the list of commands
>- **@MyBot** /create notification - generates details on how to receive notification in this room
>- **@MyBot** /login - returns the HTTP authorization header required to talk to external system
>- **@MyBot** /quote BRL - returns quote for the specified currency (e.g. BRL)
>- **@MyBot** /register quote - displays the currency quote registration form
>- **@MyBot** /template alert - renders predefined templates (e.g. alert, notification) based on your inputs


### Hello command

Simple hello world command.

>&#9679; **John Doe**
>
>@MyBot /hello

>&#9679; **MyBot**
>
>Hello, **John Doe**


### Create notification command

Returns instructions that you can use to receive notifications from external systems into the given Symphony room. To test it, submit a HTTP POST request to the returned URL.

>&#9679; **John Doe**
>
>@MyBot /create notification

>&#9679; **MyBot**
>
>| Method | Request URL |
>|--|--|
>| POST | http://localhost:8080/myproject/notification/GhaWqOo6jRsHv5adBv4q73___pK2eM94dA |
>
>| Header name | Header value |
>|--|--|
>| Accept | application/json |
>| Content-type | application/json |
>
>**Payload**
>
>Click to expand the sample payload


### Login command

Returns the HTTP header required to perform authenticated requests to external systems. Sample code includes two implementations of the AuthenticationProvider interface representing Basic and OAuth v2 authentication.

>&#9679; **John Doe**
>
>@MyBot /login

>&#9679; **MyBot**
>
>**User authenticated**. Please add the following HTTP header to your requests:
>
>```Authorization: Basic am9obi5kb2VAc3ltcGhvbnkuY29tOnN0cm9uZ3Bhc3M=```


### Quote command

Demonstrates a REST API call using `RestClient` to request for FX rates from an external
system.

Note that you will require your own API key from
[Alpha Vantage](https://www.alphavantage.co/support/#api-key) inserted into `application.yaml`.

>&#9679; **John Doe**
>
>@MyBot /quote BRL

>&#9679; **MyBot**
>
>>USD-BRL X-RATE
>>
>>**3.99**<sub>BRL</sub>


### Template command

Renders messages using Symphony standard templates. Supported templates in this sample command are:
* simple
* alert
* information
* notification
* list
* table

>&#9679; **John Doe**
>
>@MyBot /template simple {"title": "Title", "content": "Content"}

>&#9679; **MyBot**
>
>![simple template](readme/template_simple.png)

>&#9679; **John Doe**
>
>@MyBot /template alert {"title": "Title", "content": "Content"}

>&#9679; **MyBot**
>
>![alert template](readme/template_alert.png)

>&#9679; **John Doe**
>
>@MyBot /template information {"title": "Title", "content": "Content", "description": "Description"}

>&#9679; **MyBot**
>
>![information template](readme/template_information.png)

For more information about Symphony standard templates, refer to [Using Symphony standard templates](#using-symphony-standard-templates) section.


### Register quote command

Demonstrates using Symphony Elements to display a form for quote registration.

>&#9679; **John Doe**
>
>@MyBot /register quote

>&#9679; **MyBot**
>
>![symphony elements form](readme/quote_registration_form.png)


### Attachment command

Demonstrates receiving and downloading attachments, then sending them back to the sender.

>&#9679; **John Doe**
>
>@MyBot /attachment
>>attachment1.png (6.47 kB)
>>attachment1.png (12.47 kB)

>&#9679; **MyBot**
>
>![attachment](readme/attachment.png)


### Default response

The BDK also ships with a mechanism for default responses which sends a default response message in Symphony chat when bot receives an unknown command.

>&#9679; **John Doe**
>
>@MyBot /make coffee

>&#9679; **MyBot**
>
>Sorry, I could not understand


## Testing events

Similarly to commands, Symphony BDK offers a sample code for event handling. When a user is added to a room with the bot, it sends a greeting message mentioning that person:

> Hello, **John Doe**


## Testing notifications

The BDK supports receiving notifications from external systems by exposing an endpoint and
providing notification interceptors, which define how to process incoming requests.

A sample notification interceptor is shipped with the BDK. It forwards the literal JSON
payload received by the notification endpoint to the Symphony chat specified in URL path.

To test it, follow the instructions of the create notification command. Once the POST
request is received, its JSON payload is printed in the specified Symphony stream.

>&#9679; **MyBot**
>
>**Notification received:**

```javascript
{"alert": false,"title": "Something Interesting occurred!","content": {"header": "This is an example of a notification, expand to see more","body": "The BDK comes with ready-to-use message templates that you can use to render messages with your own data. You can add you own templates using the extension application."},"showStatusBar": true,"comment": {"body": "so interesting!"},"description": "this is a brief description","assignee": {"displayName": "John Doe"},"type": {"name": "sample"},"status": {"name": "Awesome"},"priority": {"name": "normal"},"labels": [{"text": "Example"},{"text": "BDK"},{"text": "MS"}]}
```


## Adding command handlers

You can add command handlers to your bot by extending the `CommandHandler` class (or its subclasses `AuthenticatedCommandHandler`, `DefaultCommandHandler` discussed later).

To extend `CommandHandler`, implement the following methods:

* **Predicate&lt;String&gt; getCommandMatcher()**
  * Define a regular expression to specify the pattern used to match Symphony messages into commands

* **void handle(BotCommand command, SymphonyMessage response)**
  * Add your business logic to handle the command
  * The `BotCommand` object contains command details (e.g. user which triggered it, room
    where the command was triggered, the raw command line, etc)
  * The `SymphonyMessage` object formats the command response. The BDK will take care of
    delivering the response to the correct Symphony room.

```java
@Override
protected Predicate<String> getCommandMatcher() {
  return Pattern
    .compile("^@"+ getBotName() + " /hello$")
    .asPredicate();
  }

@Override
public void handle(BotCommand command, SymphonyMessage response) {
  Map<String, String> variables = new HashMap<>();
  variables.put("user", command.getUserDisplayName());

  response.setTemplateMessage("Hello, <b>${user}</b>", variables);
}
```


### Command initialization

You can also add any initialization logic for your command handler in an `init()` method.

```java
@Override
public void init() {
  // Initialization logic
}
```


### Default responses

By default, bots reply to invalid commands with a friendly message. Extend the
`DefaultCommandHandler` class to add custom behavior to your bot.

Similar to the `CommandHandler` parent class, `DefaultCommandHandler` requires an
implementation for both `getCommandMatcher()` and `handle()` methods.

*Ensure the bot does not reply to unsolicited messages by only responding when it is
mentioned. This is defined by default with the `Predicates` that ship with the BDK.*

```java
@Override
protected Predicate<String> getCommandMatcher() {
  return Pattern
    .compile("^@" + getBotName())
    .asPredicate();
}

@Override
public void handle(BotCommand command, SymphonyMessage response) {
  response.setMessage("Sorry, I could not understand");
}
```


### Authenticating to external system

When integrating with external systems, bots generally need to consume APIs exposed by
such systems which require some sort of authentication.

The BDK supports that through its `AuthenticationProvider` interface and
`AuthenticatedCommandHandler` class. This allows for:

* **Separation of concerns**: isolate the authentication logic from business logic in the
  command handlers
* **Code reuse**: a single authentication method can be used in multiple commands
* **Ease of replacing the authentication method**: `AuthenticationProvider`'s
  implementation can be changed independent of business logic in the command handlers

```java
@Override
protected Predicate<String> getCommandMatcher() {
  return Pattern
    .compile("^@"+ getBotName() + " /login$")
    .asPredicate();
}

@Override
public void handle(
  BotCommand command,
  SymphonyMessage commandResponse,
  AuthenticationContext authenticationContext
) {
  String template = "<b>User authenticated</b>."
    + "Please add the following HTTP header to your requests: Authorization: %s %s";
  String response = String.format(template, authenticationContext.getAuthScheme(), authenticationContext.getAuthToken());
  commandResponse.setMessage(response);
}
```


#### AuthenticationProvider

To use the authentication support provided by the BDK, provide an implementation of the `AuthenticationProvider` interface.

The ```AuthenticationProvider``` interface defines two methods:

* **AuthenticationContext getAuthenticationContext(String userId)**:
  * Returns an ```AuthenticationContext``` object which holds authentication details for the given Symphony user.
* **void handleUnauthenticated(BotCommand command, SymphonyMessage commandResponse)**:
  * Invoked when the corresponding Symphony user has yet to be authenticated to the external system.


#### AuthenticatedCommandHandler

The `AuthenticatedCommandHandler` is a child type of `CommandHandler` which uses an
`AuthenticationProvider` to retrieve an `AuthenticationContext` before invoking the
`handle()` method. The authentication process is hence abstracted away from the command
handler.

If the Symphony user issuing the command has yet to authenticate to the external system,
`AuthenticatedCommandHandler` will defer to the `handleUnauthenticated` method in
`AuthenticationProvider` and the `handle()` method will not be invoked.

The `handle()` method in `AuthenticatedCommandHandler` receives an extra parameter,
`AuthenticationContext`, which contains details to make authenticated requests to the
external system.

**Note:** the BDK supports multiple `AuthenticationProviders`. If only one
implementation exists, the BDK will automatically inject it to all
`AuthenticatedCommandHandler` implementations. Otherwise, you will have to specify which
`AuthenticationProvider` to use with each `AuthenticatedCommandHandler` by annotating the
command handlers with the `@CommandAuthenticationProvider` annotation.

```java
@CommandAuthenticationProvider(name="BasicAuthenticationProvider")
public class LoginCommandHandler extends AuthenticatedCommandHandler {
```


### Command Matcher

In order to avoid writing complex regular expression when specifying the command pattern,
the developer can also use ```CommandMatcherBuilder```.

For example, the following regular expression pattern:

```java
Pattern
  .compile("^@BotName\\s/template(?:\\s+(?:([^\\s]+)(?:\\s+([\\s\\S]+)?)?)?)?")
  .asPredicate();
```
could be built this way with `CommandMatcherBuilder`:

```java
beginsWith("@")
  .followedBy("BotName")
  .followedBy(whiteSpace())
  .followedBy("/template")
  .followedBy(
    optional(
      nonCapturingGroup(
        oneOrMore(whiteSpace()).followedBy(
          optional(
            nonCapturingGroup(
              group(
                oneOrMore(negatedSet(whiteSpace()))
              ).followedBy(
                optional(
                  nonCapturingGroup(
                    oneOrMore(whiteSpace()).followedBy(
                      optional(
                        group(oneOrMore(any()))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  ).pattern();
```


## Handling Symphony events

Bots may need to react to events happening in Symphony rooms they are part of (e.g.
sending a greeting message to users who join the room).

Similar to commands, the BDK provides the `EventHandler` to register your bot to react to
a specific Symphony event.

To extend `EventHandler`, you need to:

* Specify the event type
  * ```EventHandler``` is a parameterized class so you need to specify which [Symphony
    event type](#available-symphony-events) you wish to handle.
* Implement `handle()`
  * This is where you add your business logic to handle the specified event. This method
    is automatically called when the specified event occurs in a room where the bot is.
  * The ```event``` object contains event details (e.g. target user or target room)
  * The ```SymphonyMessage``` object is used to format the event response. The BDK will
    take care of delivering the response to the correct Symphony room.

```java
public class UserJoinedEventHandler extends EventHandler<UserJoinedRoomEvent> {
  @Override
  public void handle(UserJoinedRoomEvent event, SymphonyMessage response) {
    String template = "Hey, <mention uid=\"%d\"/>. It is good to have you here!";
    response.setMessage(String.format(template, event.getUserId()));
  }
}
```

**Note:** While you may implement multiple `EventHandlers` to handle the same event, they
will all have their `handle()` methods called in a non-deterministic order when the event
occurs. Use a single `EventHandler` for an event if the order of execution matters.


#### Available Symphony events

* **IMCreatedEvent**: when an IM is first created with the bot
* **RoomCreatedEvent**: when a room is created with the bot
* **RoomDeactivatedEvent**: when room is deactivated
* **RoomReactivatedEvent**: when a deactivated room is reactivated
* **RoomUpdatedEvent**: when a room setting is updated
* **UserJoinedRoomEvent**: when a user joins a room that the bot is already in
* **UserLeftRoomEvent**: when a user leaves a room that the bot is in
* **RoomMemberPromotedToOwnerEvent**: when a room member is promoted to room owner
* **RoomMemberDemotedFromOwnerEvent**: when a room owner is demoted


### Bot membership governance for public rooms

The BDK offers an easy way to control whether your bots are allowed to be added to public
rooms or not.

By default, bots built with the BDK are able to join public rooms. To change that
behavior, you will need to set `isPublicRoomAllowed` to `false` in your
`application-feature.yaml` file .

It is also possible to configure a custom message the bot would send before leaving the
room, through the following configurations:

| Property                                 | Description                                                                  |
|------------------------------------------|------------------------------------------------------------------------------|
| features.isPublicRoomAllowed             | Whether bot is allowed in public rooms                                       |
| features.publicRoomNotAllowedMessage     | Message displayed before the bot leaves the room                             |
| features.publicRoomNotAllowedTemplate    | Template file with the message displayed before the bot leaves the room      |
| features.publicRoomNotAllowedTemplateMap | Template parameters of the message displayed before the bot leaves the room  |

**Simple message example:**
 ```yaml
features:
  isPublicRoomAllowed: false
  publicRoomNotAllowedMessage: Sorry, I cannot be added to public rooms
```

**Structured message example:**
 ```yaml
features:
  isPublicRoomAllowed: false
  publicRoomNotAllowedTemplate: alert
  publicRoomNotAllowedTemplateMap:
    message:
      title: Bot not allowed in public rooms
      content: Sorry, I cannot be added to public rooms
```

## Working with Symphony Elements

Symphony Elements allow bots to send messages containing interactive forms with text
fields, dropdown menus, person selectors, buttons and more.

To use Elements, extend `ElementsHandler` and implement the following methods:

* **Predicate&lt;String&gt; getCommandMatcher()**:
  * Similar to `CommandHandler`
  * Use a regular expression to specify the pattern for matching Symphony messages
* **String getElementsFormId()**: returns the Symphony Elements form ID
* **void displayElements(BotCommand command, SymphonyMessage elementsResponse)**:
  * This is where you add logic to **render** the Symphony Elements form
  * The `BotCommand` object retrieves the command details (e.g. user which triggered
    it, room where the command was triggered, the raw command line, etc).
  * The `SymphonyMessage` object is used to format the Symphony Elements form. The BDK will
    take care of delivering the response to the correct Symphony room.
* **void handleAction(SymphonyElementsEvent event, SymphonyMessage elementsResponse)**:
  * This is where you add logic to handle Elements form submissions
  * The `SymphonyElementsEvent` contains details about the action performed on the form
    (e.g. form payload, action name, etc)
  * The `SymphonyMessage` object is used to format a response according to the Elements form action.

```java
private static final String FORM_ID = "quo-register-form";
private static final String FROM_CURRENCY = "fromCurrency";
private static final String TO_CURRENCY = "toCurrency";
private static final String AMOUNT = "amount";
private static final String ASSIGNED_TO = "assignedTo";

@Override
protected Predicate<String> getCommandMatcher() {
  return Pattern
    .compile("^@" + getBotName() + " /register quote$")
    .asPredicate();
}

@Override
protected String getElementsFormId() {
  return FORM_ID;
}

@Override
public void displayElements(BotCommand command, SymphonyMessage elementsResponse) {
  Map<String, String> data = new HashMap<>();
  data.put("form_id", getElementsFormId());
  elementsResponse.setTemplateFile("quote-registration", data);
}

@Override
public void handleAction(SymphonyElementsEvent event, SymphonyMessage elementsResponse) {
  Map<String, Object> formValues = event.getFormValues();
  Map<String, Object> data = new HashMap<String, Object>();
  data.put(FROM_CURRENCY, formValues.get(FROM_CURRENCY));
  data.put(TO_CURRENCY, formValues.get(TO_CURRENCY));
  data.put(AMOUNT, formValues.get(AMOUNT));
  data.put(ASSIGNED_TO, event.getUser().getDisplayName());

  String template = "Quote FX {{fromCurrency}}-{{toCurrency}} {{amount}} sent to dealer {{assignedTo}}";
  elementsResponse.setTemplateMessage(template, data);
}
```

Sample [Handlebars](https://github.com/jknack/handlebars.java)-based template for the quote registration form:
```xml
<form id="{{form_id}}">
  <h3>Quote Registration</h3>
  <h6>From currency</h6>
  <text-field minlength="3" maxlength="3" masked="false" name="fromCurrency" required="true"></text-field>
  <h6>To currency</h6>
  <text-field minlength="3" maxlength="3" masked="false" name="toCurrency" required="true"></text-field>
  <h6>Amount</h6>
  <text-field minlength="1" maxlength="9" masked="false" name="amount" required="true"></text-field>
  <h6>Assigned To:</h6>
  <person-selector name="assignedTo" placeholder="Assign to.." required="false" />
  <h6>Quote Status:</h6>
  <radio name="status" checked="true" value="pending">Pending</radio>
  <radio name="status" checked="false" value="confirmed">Confirmed</radio>
  <radio name="status" checked="false" value="settled">Settled</radio>
  <h6>Remarks:</h6>
  <textarea name="remarks" placeholder="Enter your remarks.." required="false"></textarea>
  <button name="confirm" type="action">Confirm</button>
  <button name="reset" type="reset">Reset</button>
</form>
```

**Note:** Calling `event.getFormValues()` returns a map with the values of all input
fields in the Symphony Elements form. The key names of that map will match the MessageML
`name` field of the Elements in the form. The values are provided as `Objects` as they can
either contain a `String` or a `List<Long>` in `<person-selector>`


### ElementsActionHandler
To handle Elements form submissions that did not originate from your bot, you can use
`ElementsActionHandler` instead of `ElementsHandler`.

For scenarios where the Symphony Elements form is not generated through a command targeted
to your bot (e.g. a user interacting with an extension app, a notification from external
system) but you need to handle the interactions with that form, extend the
```ElementsActionHandler``` class rather than ```ElementsHandler```.

```ElementsActionHandler``` is actually an ```EventHandler``` and therefore is simpler and easier to extend than ```ElementsHandler```. It just requires implementing the ```getElementsFormId``` and ```handle``` methods.


## Receiving notifications

Receiving notifications from external systems directly into Symphony chats is another common use case for bots and Symphony BDK delivers all the support you need by:

1. Exposing the ```/notification``` endpoint through which external systems can send their events: http(s)://&lt;hostname&gt;:&lt;port&gt;/&lt;application_context&gt;/notification

2. Offering mechanisms for you to register your own logic to process incoming notification requests through the ```NotificationInterceptor``` class, including discarding requests when applicable

3. Sending notification contents to Symphony rooms

4. Protecting the ```/notification``` endpoint


### Processing incoming requests

Incoming requests can be easily processed by extending the ```NotificationInterceptor``` class. The way Symphony BDK supports processing notifications mimics the Filter idea of the Java Servlet specification, that is, you can chain multiple ```NotificationInterceptor``` classes together each one tackling a different aspect of the request, but all of them collaborating to either process or discard the request.

Extending ```NotificationInterceptor``` class will automatically register your interceptor to the BDK internal ```InterceptorChain```.

To create your own ```NotificationInterceptor``` you simply need to implement the following method:

* **boolean process(NotificationRequest notificationRequest, SymphonyMessage notificationMessage)**: where you add your business logic to process incoming requests (e.g. HTTP header verification, JSON payload mapping, etc). Use the ```NotificationRequest``` to retrieve all details of the notification request (e.g. headers, payload, identifier). You can also use its ```getAttribute```/```setAttribute``` methods to exchange data among your interceptors. Use the ```SymphonyMessage``` object to format the notification. The BDK will take care of delivering the response to the correct Symphony room. This method is automatically called for each notification request. Return false if the request should be discarded, true otherwise.

```java
  @Override
  public boolean process(NotificationRequest notificationRequest, SymphonyMessage notificationMessage) {

    // For simplicity of this sample code identifier == streamId
    String streamId = notificationRequest.getIdentifier();

    if (streamId != null) {
      notificationRequest.setStreamId(streamId);
      notificationMessage.setMessage(
          "<b>Notification received:</b><br />" + notificationRequest.getPayload());
      return true; // true if notification interception chain should continue
    }

    return false; // false if notification intercept chain should be halted and request rejected
  }

```


### Controlling interceptors order

If you need to specify multiple request interceptors and want to control their execution order, extend the ```OrderedNotificationInterceptor``` rather than ```NotificationInterceptor``` and implement the ```getOrder()``` method.


### Forwarding notifications to rooms

The notification support offered by the BDK uses an extra path parameter (that is, ```/notification/<some_value>```) to identify which room a particular notification should be sent to. That extra parameter is internally called as 'identifier' and can be retrieved from the ```NotificationRequest``` object.

By default the BDK assumes the 'identifier' is the stream ID of the room. If for your scenario 'identifier' means something else or you have a completely different mechanism to identify the room, you must set the stream ID in ```NotificationRequest``` manually.


### Protecting notifications endpoint

Notification endpoint is public by default. Nevertheless Symphony BDK has a built-in IP whitelisting mechanism that could be easily set up to allow only specific IP addresses or IP ranges to have access that endpoint.

You can enable and configure that mechanism by adding the following in ```application-dev.yaml``` file:

```yaml
access-control:
  ipWhitelist: <comma-separated IP list>
  urlMapping: "/notification"
```

## Sending messages

The ```SymphonyMessage``` object holds the details for a message to be sent to Symphony. It offers the following different ways to specify the message content:

* **void setMessage(String message)**: specifies a static message to be displayed in a Symphony room.

* **void setTemplateMessage(String templateMessage, Object templateData)**: automatically interpolates a string with template wildcards using the given data object.

* **void setTemplateFile(String templateFile, Object templateData)**: automatically loads the specified template file and interpolates its content using the given data object. Template files must be placed in your resources directory under ```templates```.

* **void setEnrichedMessage(String message, String entityName, Object entity, String version)**: similar to ```setMessage``` but offers data to for an extension app to create enriched messages replacing what has been specified as ```message```. If no extension app is registered, the ```message``` gets displayed.

* **void setEnrichedTemplateMessage(String templateMessage, Object templateData, String entityName, Object entity, String version)**: similar to ```setTemplateMessage``` but offers data to for an extension app to create enriched messages replacing what has been specified as ```templateMessage```. If no extension app is registered, the interpolated ```templateMessage``` gets displayed.

* **void setEnrichedTemplateFile(String templateFile, Object templateData, String entityName, Object entity, String version)**: similar to ```setTemplateFile``` but offers data to for an extension app to create enriched messages replacing what has been specified as ```templateFile```. If no extension app is registered, the interpolated content of ```templateFile``` gets displayed.

Symphony BDK is shipped with [Handlebars](https://github.com/jknack/handlebars.java) template engine and automatically handles the template processing for you.


### Using Symphony standard templates

Symphony BDK integrates seamlessly with [SmsRenderer](https://github.com/SymphonyPlatformSolutions/sms-sdk-renderer-java) tool to offer predefined message templates.

The file based methods in ```SymphonyMessage``` (```setTemplateFile``` and ```setEnrichedTemplateFile```) can be used to render such templates. For that, you just need to specify the predefined template from ```SmsRenderer.SmsTypes``` enum.

Example:

```java
public class TemplateSampleHandler extends CommandHandler {

  @Override
  protected Predicate<String> getCommandMatcher() {
    ...
  }

  @Override
  public void handle(BotCommand command, SymphonyMessage commandResponse) {
    Map<String, Object> commandParameter =
        jsonMapper.toObject("{\"message\": {\"title\": \"Title\", \"content\": \"Content\"}}", Map.class);
    commandResponse.setTemplateFile(SmsRenderer.SmsTypes.ALERT.getName(), commandParameter);
  }

}
```

Currently, Symphony BDK offers the following templates:

* ALERT
* INFORMATION
* LIST
* NOTIFICATION
* SIMPLE
* TABLE

For more information about the Symphony standard templates, take a look on https://github.com/SymphonyPlatformSolutions/sms-sdk-renderer-java. Also, check [Template command](#template-command) section.


## Extending health metrics

The Symphony BDK monitoring system is based on Spring Actuators. By default, it exposes the following health metrics:

* **overall system health status**: represented by the top ```status``` field. It shows 'UP' if all other metrics are fine, that is, 'UP'.
* **diskspace**: disk space metrics. It shows 'DOWN' when the available disk space is below the defined threshold.
* **symphony**: symphony components metrics. It shows 'UP' only if your bot is properly communicating with the POD and agent and all Symphony components (e.g. agent, Key Manager, POD) are accessible.

```javascript
{
    "status":"UP",
    "details":{
        "diskSpace":{
            "status":"UP",
            "details":{
                "total":267985612800,
                "free":110891438080,
                "threshold":10485760
            }
        },
        "symphony":{
            "status":"UP",
            "details":{
                "Symphony":{
                    "agentConnection":"UP",
                    "podConnection":"UP",
                    "agentToPodConnection":"UP",
                    "agentToKMConnection":"UP",
                    "podVersion":"1.55.3",
                    "agentVersion":"2.55.9",
                    "agentToPodConnectionError":"N/A",
                    "agentToKMConnectionError":"N/A"
                }

            }
        }
    }
}
```

There are many other built-in metrics in Spring Actuator. Please refer to their documentation for enabling those metrics.

To create your own custom metric you need to implement the Spring Actuator ```HealthIndicator``` interface and use ```Health``` builder to convey your status. Your metrics are automatically integrated with the system ones in the monitoring endpoint: http(s)://&lt;hostname&gt;:&lt;port&gt;/&lt;application_context&gt;/monitor/health.

```java
public class InternetConnectivityHealthIndicator implements HealthIndicator {

  private RestClient restClient;

  public InternetConnectivityHealthIndicator(RestClient restClient) {
    this.restClient = restClient;
  }

  @Override
  public Health health() {
    try {
      restClient.getRequest("https://symphony.com", String.class);
      return Health.up().withDetail("connectivity", "UP").build();
    } catch (Exception e) {
      return Health.down().withDetail("connectivity", "DOWN").build();
    }
  }

}
```


## Extension applications

In addition to all support for bots development, Symphony BDK also comes with great tools to streamline the Symphony-extension apps integration process.


### Extension app authentication

The extension app authentication process spawns three steps which aim to establish a bidirectional trust between an application and Symphony.

Symphony BDK removes all the complexity related to the authentication process by exposing the following endpoints through which an application can authenticate itself:

| Method | Endpoint | Description | Request | Response
|---|---|---|---|---|
| POST | /application/**authenticate** | Initiates the authentication process. Extension app sends its application ID, retrieved from Symphony Client APIs, which must match the same ID configured in Symphony Admin portal. An application token is returned to the extension app. |  `{"appId": "myAppId"}` | `{"appId": "myAppId", "appToken": "bde...e"}` |
| POST | /application/**tokens/validate** |  Validates the application and Symphony tokens generated in previous step. Extension app provides the Symphony token, obtained through Symphony Client APIs. | `{"appToken":"05b...c",` `"symphonyToken":"0...6",` `"appId":"myAppId"}` | 200 OK if tokens valid, 401 Unauthorized otherwise |
| POST | /application/**jwt/validate** | Validates a signed JWT holding user details  |  `{"jwt":"ey...g"}` | the user ID |

Extension apps must rely on those three enpoints in the order they are described to get authenticated to Symphony. If any of those steps fails, the authentication fails and extension app will not be launched (i.e. not displayed on the left-nav menu).


### Exposing new endpoints

The web support in Symphony BDK is based on SpringMVC framework. So exposing endpoints for your extension apps requires:

* Annotating your classes with ```@Controller``` or ```@RestController```
* Mapping your routes using ```@RequestMapping```, ```@GetMapping```, ```@PostMapping```, etc

```java
@RestController
@RequestMapping("/secure/myendpoint")
public class MyController {

  @GetMapping
  public ResponseEntity getSomeData() {
    // ... logic to retrieve data
    return ResponseEntity.ok(new Object());
  }

  @PostMapping
  public ResponseEntity setSomeData(@RequestBody String data) {
    // ... logic to set data
    return ResponseEntity.ok();
  }
}

```

### Protecting endpoints

When exposing endpoints for extension apps you will likely need to restrict access to them.

Symphony BDK offers a simple way for you to protect endpoints so that only your applications would have access to them. All endpoints exposed under ```/secure/``` path are automatically protected.

To access them, Symphony BDK requires requests to have the HTTP authorization header set with a valid JWT:

```Authorization: Bearer eyJ...ybxRg```

It is possible to configure a different value for the secure path. In ```bot-config.json``` change the following property:

```jvascript
  "authenticationFilterUrlPattern": "/secure/",
```

Be sure to reflect your change to all of your controllers.


### Symphony clients

Typically extension apps deliver features that involve retrieving/persisting data from/to Symphony. Symphony BDK provides the building blocks for such features, the Symphony clients.

The following clients are available:

* ```MessageClient```: offers ways to send messages to Symphony rooms
* ```StreamsClient```: retrieves streams and rooms details and manages rooms
* ```UsersClient```: retrieves user details

```java
  private final StreamsClient streamsClient;

  public StreamsController(StreamsClient streamsClient) {
    this.streamsClient = streamsClient;
  }

  @GetMapping
  public ResponseEntity<List<SymphonyStream>> getUserStreams() {
    try {
      return ResponseEntity.ok(streamsClient.getUserStreams(null, true));
    } catch (SymphonyClientException sce) {
      // ... handling communication failure with Symphony
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
    }
  }

```

**Notice:** For any communication issue with Symphony a ```SymphonyClientException``` is raised. Handle that exception properly to improve user experience.


### Serving the extension app

Static assets of an extension app (e.g. javascript, css, images, html) can be served either in a separated host or along with the bundle you generate for your Symphony BDK.

If you plan to have a different server for you web UI, make sure CORS is properly configured. In ```application-dev.yaml``` add the following properties:

```yaml
cors:
  allowed-origin: "<web UI domain>"
  url-mapping: "/**"

```

To distribute the extension app as part of your Symphony BDK based application, place all of you static assets under: ```<symphony bot application base path>/src/main/resources/public``` and build your application. In this case, all of your assets will be under ```/app/``` path. Example,  my_image.png file placed under ```public``` directory would be accessible in the following URL:

```http(s)://<hostname>:<port>/<application_context>/app/my_image.png```

**Notice:** When registering your extension apps in Symphony Admin portal, make sure you take the ```/app/``` into account when setting the load URL.


### Testing your app

Symphony BDK ships with few endpoints to assist developers on understanding how to leverage Symphony BDK to create their own extension apps. All endpoints are protected and require extension app to be authenticated.

Please refer to following sub-sections for more details.


#### Streams details endpoint

| Method | URL | Description
|---|---|---|
| GET | /secure/streams | Returns a list of streams the bot is part of

**Response**

```javascript
[
  {
    "active": true,
    "crossPod": true,
    "members": [
      7215545078229
    ],
    "roomName": " my room name",
    "streamId": "iWyZBIOdQQzQj0tKOLRivX___qu6YeyZdA",
    "streamType": "ROOM"
  }
]
```


#### Users details endpoint

| Method | URL | Description
|---|---|---|
| GET | /secure/users | Returns user details by username or user ID. Set either ```username``` or ```userId``` request parameter.

**Response**

```javascript
{
  "userId": 15942919536460,
  "emailAddress": "test_1@symphony.com",
  "firstName": "test_1",
  "lastName": "test",
  "displayName": "test_1 test",
  "title": "Technical Writer",
  "company": "pod232",
  "username": "test_1",
  "location": "location",
  "avatars": [
    {
      "size": "original",
      "url": "../avatars/static/150/default.png"
    }
  ]
}

```


#### Extension app log endpoint

| Method | URL | Description
|---|---|---|
| POST | /secure/log | Persists extension apps logs along with server-side logs. Set ```level``` request parameter to change log level

**Request**

```javascript
"a log message from frontend"

```


#### Static content

Under ```<symphony bot application base path>/src/main/resources/public``` you will find a sample Symphony logo (logo.svg).

Try accessing it from:
* browser (full path URL): ```http(s)://<hostname>:<port>/<application_context>/app/logo.svg```
* your extension app code (relative path): ```./logo.svg```


### Automatic endpoint documentation

Symphony BDK is shipped with [Swagger](https://swagger.io/tools/open-source/getting-started/) already configured. Documentation for all existing endpoints and new ones that you may add can be found here:

```
http(s)://<hostname>:<port>/<application_context>/swagger-ui.html

```


## Real-Time events

With Symphony BDK your extension apps can quickly leverage real-time events. Based on the Server-Sent Event (SSE) technology, Symphony BDK delivers real-time events support through the following components:

* ```SseController``` which exposes the endpoint through which extension applications subscribe for real-time events
* ```SsePublisher```, a base class to create real-time event generators
* ```SseSubscriber```, an abstraction of clients subscribing for events


### Generating events

```SsePublisher``` child classes represent event generators. To extend ```SsePublisher``` implement the following methods:

* **List&lt;String&gt; getStreams()**: returns a list of event stream names that this particular publisher is responsible for. Clients must specify the streams they want to listen events to in their requests.

* **void stream(SseSubscriber subscriber)**: where you add your business logic to generate events. This method is automatically called when clients request events for any stream handled by this particular publisher. Use the ```SseSubscriber``` object to retrieve details of the clients subscribing for events and to send them your events.

```java
  private static final long WAIT_INTERVAL = 1000L;

  @Override
  public List<String> getStreams() {
    return Stream.of("stream1", "stream2")
        .collect(Collectors.toList());
  }

  @Override
  public void stream(SseSubscriber subscriber) {
    for (int i = 0; true; i++) {
      SseEvent event = SseEvent.builder()
          .name("test_event")
          .data("SSE Test Event - " + LocalTime.now().toString())
          .id(String.valueOf(i))
          .retry(WAIT_INTERVAL)
          .build();
      LOGGER.debug("sending event with id {}", event.getId());

      try {
        subscriber.onEvent(event);
      } catch (SsePublishEventException spee) {
        LOGGER.warn("Failed to deliver event with ID: " + event.getId());
      }

      waitForEvents(WAIT_INTERVAL);
    }
  }
```


### Subscribing to event streams

| Method | URL | Description
|---|---|---|
| GET | /secure/events/&lt;comma separated stream names&gt; | Subscribe to the specified event streams. Use query params to filter events.

**Client sample**

```javascript

// Listening to stock price updates
const evtSource = new EventSource("http://localhost:8080/botapp/secure/events/stockprice");

```


### Event stream mapping

If you have multiple ```SsePublisher``` generating events of different nature (e.g. stock prices and currencies exchange rates), you can name the event streams so that subscribers are properly served by the corresponding publishers.

Symphony BDK automatically maps clients requests to the corresponding publishers based on the stream names present in the request path (e.g. /stockprice, /x-rate). Stream names in client requests must match the ones registered by publishers through ```getStreams()``` method.

**Client sample**

```javascript

// Listening to stock price updates only
const evtSource = new EventSource("http://localhost:8080/botapp/secure/events/stockprice");

// Listening to stock price and x-rate updates
const evtSource2 = new EventSource("http://localhost:8080/botapp/secure/events/stockprice,x-rate");


```

### Filtering events

Real-time events may be filtered based on some criteria. All query parameters in a subscription request are handled by Symphony BDK as filtering criteria and forwarded to publishers through ```SseSubscriber``` object.


```javascript

// Listening to Tesla stock price updates
const evtSource = new EventSource("http://localhost:8080/botapp/secure/events/stockprice?name=TSLA");

```

The publisher then checks if there are any specified filters:

```java
  @Override
  public void stream(SseSubscriber subscriber) {

    ...

    Map<String, String> filter = subscriber.getFilters();
    if (price.getStockName().equals(filter.get("name")) {
      // generate SSE event
    }

    ...
  }

```


## Advanced settings

### Custom truststore
If SSL connection to any endpoint uses private or self-signed certificates, add the following properties to the ```bot-config.json``` to tell the BDK which truststore to use:

```javascript
"truststorePath": "/path/to/truststore/",
"truststorePassword": "truststore password",

```

### Proxy support

In case connection to Symphony components (e.g. POD, agent, key manager) requires going through proxies, the following properties can be set in ```bot-config.json```:

```javascript
// If only POD access requires proxy. Username/password only required
// if proxy uses basic authentication
"podProxyURL": "proxy url",
"podProxyUsername": "username",
"podProxyPassword": "password",

// If access to both POD and agent requires proxy
"proxyURL": "proxy url",
"proxyUsername": "username",
"proxyPassword": "password",

// If access to key manager requires proxy
"keyManagerProxyURL": "proxy url",
"keyManagerProxyUsername": "username",
"keyManagerProxyPassword: "password",

```

For connections to external systems using the REST client shipped with Symphony BDK define the following properties in ```application-dev.yaml```:

```yaml
restclient:
  proxy:
    address: "proxy hostname"
    port: "proxy port"

```


### Logging

To change log file name and/or location, or to change log level for different packages, set the following properties in ```application-dev.yaml```.

```yaml
logging:
  file: /home/myuser/symphony-bot-sdk/logs/bot-app.log
  level:
    ROOT: INFO
    com.symphony.ms.bot.sdk.internal: DEBUG

```

### Access control

To protect endpoints using basic authentication and/or IP whitelist, specify the following in ```application-dev.yaml```:

```yaml
access-control:
  name: myusername
  hashedPassword: 5e88489...21d1542d8
  salt: 11111
  ipWhitelist: 192.168.0.155, 192.168.2.178
  urlMapping: /monitor

```

**Notice:** The basic authentication protection is pretty simple allowing only one username/password to be specified.


### CORS

If extension app is running in different host, rely on the CORS support to make Symphony BDK to accept requests coming from the extension app. In ```application-dev.yaml``` add:

```yaml
cors:
  allowed-origin: myextensionapp.com
  url-mapping: /**

```


### Cross-site scripting

Protect endpoint from XSS attacks by setting the following properties in ```application-dev.yaml```:

```yaml
xss:
  url-mapping: /secure/*

```


### Request origin header

It is also possible to protect endpoints based on shared secrets. This is particularly useful when your application needs to receive notifications from external systems and therefore needs to expose a publicly available endpoint.

Both the external system and your application could share a secret through some secure channel. On every notification sent, the external system would add that secret in a HTTP header and Symphony BDK would automatically reject requests without it.

In ```application-dev.yaml``` add the following:

```yaml
request-origin:
  origin-header: x-origin-token
  url-mapping: /notification

```


### Rate limit

It is possible to limit access to your application using the Symphony BDK's throttling mechanism. You need to specify the limit and one of the throttling mode:

* ORIGIN: limits request rate based on origin IP address
* ENDPOINT: limits request rate per endpoints exposed by your application (default if not specified)

**Notice:** When application is running behind load balancers or firewalls, the calling IP address may be rewritten. Usually such network components keep the original IP address in HTTP headers. Symphony BDK looks for the following headers when throttling in ORIGIN mode:

* X-Forwarded-For
* Proxy-Client-IP
* WL-Proxy-Client-IP
* HTTP_X_FORWARDED_FOR
* HTTP_X_FORWARDED
* HTTP_X_CLUSTER_CLIENT_IP
* HTTP_CLIENT_IP
* HTTP_FORWARDED_FOR
* HTTP_FORWARDED
* HTTP_VIA
* REMOTE_ADDR

Example: specify that the same IP address can issue at most 200 concurrent requests per second

```yaml
throttling:
  limit: 200
  mode: ORIGIN
  timeout: 10000

```

The timeout property is used to define the maximum amount of time a request waits in throttling mechanism before it is processed. If that time exceeds, a HTTP 408 error is returned to the caller.


### Settings reference

|                 Property                 |                                          Description                                         |    Configuration file    |
|------------------------------------------|----------------------------------------------------------------------------------------------|--------------------------|
| truststorePath                           | The truststore path                                                                          | bot-config.json          |
| truststorePassword                       | The truststore password                                                                      | bot-config.json          |
| podProxyURL                              | The pod proxy URL                                                                            | bot-config.json          |
| podProxyUsername                         | The pod proxy username                                                                       | bot-config.json          |
| podProxyPassword                         | The pod proxy password                                                                       | bot-config.json          |
| proxyURL                                 | The agent and pod proxy URL                                                                  | bot-config.json          |
| proxyUsername                            | The agent and pod proxy username                                                             | bot-config.json          |
| proxyPassword                            | The agent and pod proxy password                                                             | bot-config.json          |
| keyManagerProxyURL                       | The key manager proxy URL                                                                    | bot-config.json          |
| keyManagerProxyUsername                  | The key manager proxy username                                                               | bot-config.json          |
| keyManagerProxyPassword                  | The key manager proxy password                                                               | bot-config.json          |
| server.port                              | Port to be used by application (e.g. 8080)                                                   | application-dev.yaml     |
| server.servlet.context-path              | Application context path (e.g. /botapp)                                                      | application-dev.yaml     |
| certs                                    | Path to the directory containing bot private key                                             | application-dev.yaml     |
| logging.file                             | The log file path (including file name)                                                      | application-dev.yaml     |
| logging.level.&lt;package&gt;            | The log level for the given package (e.g. DEBUG, INFO, WARN, ERROR)                          | application-dev.yaml     |
| access-control.name                      | The username for basic authentication                                                        | application-dev.yaml     |
| access-control.hashedPassword            | The salted hashed password for basic authentication                                          | application-dev.yaml     |
| access-control.salt                      | Salt used when hashing password                                                              | application-dev.yaml     |
| access-control.ipWhitelist               | The IP whitelist set                                                                         | application-dev.yaml     |
| access-control.urlMapping                | The endpoints protected by either basic authentication or IP whitelist                       | application-dev.yaml     |
| concurrency.pools.bot.coreSize           | The bot concurrency pools coreSize                                                           | application-dev.yaml     |
| concurrency.pools.bot.maxSize            | The bot concurrency pools max size                                                           | application-dev.yaml     |
| concurrency.pools.bot.queueCapacity      | The bot concurrency pools queue capacity                                                     | application-dev.yaml     |
| concurrency.pools.bot.threadNamePrefix   | The bot concurrency pools thread name prefix                                                 | application-dev.yaml     |
| concurrency.pools.sse.coreSize           | The SSE concurrency pools coreSize                                                           | application-dev.yaml     |
| concurrency.pools.sse.maxSize            | The SSE concurrency pools max size                                                           | application-dev.yaml     |
| concurrency.pools.sse.queueCapacity      | The SSE concurrency pools queue capacity                                                     | application-dev.yaml     |
| concurrency.pools.sse.threadNamePrefix   | The SSE concurrency pools thread name prefix                                                 | application-dev.yaml     |
| cors.allowed-origin                      | The allowed origin domain                                                                    | application-dev.yaml     |
| cors.url-mapping                         | The endpoints which CORS support should be applied to                                        | application-dev.yaml     |
| xss.url-mapping                          | The endpoints which cross-site scripting protection should be applied to                     | application-dev.yaml     |
| request-origin.origin-header             | The HTTP header used to convey the request origin secret                                     | application-dev.yaml     |
| request-origin.url-mapping               | The endpoints for which origin header should be verified                                     | application-dev.yaml     |
| restclient.proxy.address                 | The rest client proxy address                                                                | application-dev.yaml     |
| restclient.proxy.port                    | The rest client port                                                                         | application-dev.yaml     |
| restclient.timeout                       | The rest client timeout                                                                      | application-dev.yaml     |
| throttling.limit                         | Limits the number of requests per second                                                     | application-dev.yaml     |
| throttling.mode                          | Throttling modes: ORIGIN - throttle based on IP or ENDPOINT - throttle based on target endpoint. If not specified, default to ENDPOINT | application-dev.yaml     |
| throttling.timeout                       | Maximum amount of time a request waits before a HTTP 408 is returned to client               | application-dev.yaml     |
| features.commandFeedback                 | The command feedback enablement                                                              | application-feature.yaml |
| features.transactionIdOnError            | The transaction id on error enablement                                                       | application-feature.yaml |
| features.eventUnexpectedErrorMessage     | The message for unexpected errors on events                                                  | application-feature.yaml |
| features.notificationBaseUrl             | The notification base URL                                                                    | application-feature.yaml |
| features.isPublicRoomAllowed             | The enablement for allowing bot addition to public rooms                                     | application-feature.yaml |
| features.publicRoomNotAllowedMessage     | The message when adding bots to public rooms is not allowed                                  | application-feature.yaml |
| features.publicRoomNotAllowedTemplate    | The template to be used when adding bots to public rooms is not allowed                      | application-feature.yaml |
| features.publicRoomNotAllowedTemplateMap | The parameter of the template to be used when adding bots to public rooms is not allowed     | application-feature.yaml |
